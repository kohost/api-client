/* eslint-disable */
import { Ajv } from "ajv";
import addFormats from "ajv-formats";
import fs from "node:fs";
import path from "node:path";
import * as prettier from "prettier";

const GENERATED_DIR = ".generated";
const MODELS_DIR = path.join(GENERATED_DIR, "models");
const USE_CASES_DIR = path.join(GENERATED_DIR, "useCases");

async function formatCode(code) {
  return await prettier.format(code, { parser: "typescript" });
}

const banner = `/* This file is automatically generated. Do not modify it manually. */`;

const useCaseJson = fs.readFileSync("src/apiUseCases.json", {
  encoding: "utf-8",
});

/**
 * @type {Map<string, {http: boolean | {method: "GET" | "PUT" | "POST" | "DELETE", path: string, disableAuth?: boolean}, description?: string}>}
 */
const useCases = new Map(JSON.parse(useCaseJson));

// Map of schema titles to their schema variable names and type names
function getSchemaNames(schemaTitle) {
  const baseName = schemaTitle.replace(/\s+/g, "");
  const varName = baseName.charAt(0).toLowerCase() + baseName.slice(1);
  return {
    schemaVar: `${varName}Schema`,
    typeName: `${baseName}Schema`,
    className: baseName,
    fileName: varName,
  };
}

/**
 * Extract method source code from a TypeScript source file
 * This preserves type annotations that would be lost when using func.toString()
 * @param {string} sourceFile - Path to the source file
 * @param {string} exportName - Name of the export (e.g., "methods", "getters", "statics")
 * @returns {Map<string, string>} Map of method names to their source code
 */
function extractMethodsFromSource(sourceFile, exportName) {
  if (!fs.existsSync(sourceFile)) return new Map();

  const content = fs.readFileSync(sourceFile, "utf-8");
  const methods = new Map();

  // Find the export const block - use a greedy match that stops at the last };
  const exportRegex = new RegExp(
    `export const ${exportName}\\s*=\\s*\\{([\\s\\S]*?)\\n\\};`,
    "m",
  );
  const match = content.match(exportRegex);
  if (!match) return methods;

  const block = match[1];

  // Extract individual methods - match method name followed by ( for params
  // Skip JSDoc comments separately and don't include them
  const methodRegex = /(?:^|\n)\s*([\w]+)\s*\(([^)]*)\)\s*\{/g;
  let methodMatch;

  while ((methodMatch = methodRegex.exec(block)) !== null) {
    const methodName = methodMatch[1];

    // Skip JSDoc comment marker captures
    if (methodName === "function") continue;

    // Find the start of method definition (the method name position)
    let methodStart = methodMatch.index;
    // Skip leading whitespace/newline
    while (
      methodStart < block.length &&
      (block[methodStart] === "\n" || block[methodStart] === " ")
    ) {
      methodStart++;
    }

    // Find matching closing brace, accounting for strings, template literals, and comments
    let braceCount = 0;
    let inString = false;
    let inComment = false;
    let inMultiLineComment = false;
    let stringChar = "";
    let bodyStart = block.indexOf("{", methodMatch.index);
    let i = bodyStart;

    for (; i < block.length; i++) {
      const char = block[i];
      const nextChar = i < block.length - 1 ? block[i + 1] : "";
      const prevChar = i > 0 ? block[i - 1] : "";

      // Handle multi-line comments
      if (!inString && !inComment && char === "/" && nextChar === "*") {
        inMultiLineComment = true;
        i++; // skip next char
        continue;
      }
      if (inMultiLineComment && char === "*" && nextChar === "/") {
        inMultiLineComment = false;
        i++; // skip next char
        continue;
      }
      if (inMultiLineComment) continue;

      // Handle single-line comments
      if (!inString && !inComment && char === "/" && nextChar === "/") {
        inComment = true;
        continue;
      }
      if (inComment && char === "\n") {
        inComment = false;
        continue;
      }
      if (inComment) continue;

      // Handle strings
      if (inString) {
        if (char === stringChar && prevChar !== "\\") {
          inString = false;
        }
      } else {
        if (char === '"' || char === "'" || char === "`") {
          inString = true;
          stringChar = char;
        } else if (char === "{") {
          braceCount++;
        } else if (char === "}") {
          braceCount--;
          if (braceCount === 0) {
            break;
          }
        }
      }
    }

    const methodSource = block.slice(methodStart, i + 1).trim();
    // Remove trailing comma if present
    const cleanedSource = methodSource.replace(/,\s*$/, "");
    methods.set(methodName, cleanedSource);
  }

  return methods;
}

async function loadSchemas() {
  const schemaFiles = fs
    .readdirSync("src/schemas")
    .filter(
      (fileName) =>
        fileName.endsWith(".ts") &&
        fileName !== "index.ts" &&
        fileName !== "definitions.ts",
    );

  const modules = await Promise.all(
    schemaFiles.map(async (file) => {
      const module = await import(`../src/schemas/${file}`);
      // Find the schema export (it's now a named export like alarmSchema)
      const schemaKey = Object.keys(module).find(
        (k) => k.endsWith("Schema") && typeof module[k] === "object",
      );
      const schema = module[schemaKey];
      return [file, { ...module, default: schema, schemaKey }];
    }),
  );

  const map = new Map(modules);
  return map;
}

// Ensure directories exist
function ensureDirectories() {
  if (!fs.existsSync(GENERATED_DIR)) {
    fs.mkdirSync(GENERATED_DIR, { recursive: true });
  }
  if (!fs.existsSync(MODELS_DIR)) {
    fs.mkdirSync(MODELS_DIR, { recursive: true });
  }
  if (!fs.existsSync(USE_CASES_DIR)) {
    fs.mkdirSync(USE_CASES_DIR, { recursive: true });
  }
}

loadSchemas().then(async (schemas) => {
  ensureDirectories();

  // Generate validate.ts
  const validateCode = await generateValidatorCode(schemas);
  fs.writeFileSync(
    path.join(GENERATED_DIR, "validate.ts"),
    await formatCode(validateCode),
  );

  const ajv = new Ajv({
    allErrors: true,
    useDefaults: true,
    strict: false,
    allowMatchingProperties: true,
    allowUnionTypes: true,
    strictRequired: false,
    schemas: Array.from(schemas.entries()).map(([fileName, module]) => {
      return module.default;
    }),
  });

  addFormats(ajv);

  // Generate model files
  const modelNames = [];
  for (const [fileName, module] of schemas) {
    const schema = module.default;
    if (schema.$id === "definitions.json") continue;

    const names = getSchemaNames(schema.title);
    modelNames.push(names);

    const modelCode = generateModelCode(schema, module, names);
    fs.writeFileSync(
      path.join(MODELS_DIR, `${names.fileName}.ts`),
      await formatCode(modelCode),
    );
  }

  // Generate models index.ts
  const modelsIndexCode = generateModelsIndex(modelNames);
  fs.writeFileSync(
    path.join(MODELS_DIR, "index.ts"),
    await formatCode(modelsIndexCode),
  );

  // Generate use case files
  const useCaseNames = [];
  for (const [useCase, data] of useCases.entries()) {
    if (data.http) {
      const useCaseFileName =
        useCase.charAt(0).toLowerCase() + useCase.slice(1);
      useCaseNames.push(useCaseFileName);
      const code = generateUseCaseCode(useCase, data.http, data.description);
      fs.writeFileSync(
        path.join(USE_CASES_DIR, `${useCaseFileName}.ts`),
        await formatCode(code),
      );
    }
  }

  // Generate useCases index.ts
  const useCasesIndexCode = generateUseCasesIndex(useCaseNames);
  fs.writeFileSync(
    path.join(USE_CASES_DIR, "index.ts"),
    await formatCode(useCasesIndexCode),
  );

  console.log(`Generated files in ${GENERATED_DIR}/`);
  console.log(`  - validate.ts`);
  console.log(`  - models/ (${modelNames.length} files)`);
  console.log(`  - useCases/ (${useCaseNames.length} files)`);
});

/**
 * @param {Map<string, object>} schemas
 */
async function generateValidatorCode(schemas) {
  const imports = [];
  const schemaList = [];
  const exports = [];

  for (const [fileName, module] of schemas.entries()) {
    const schema = module.default;
    const baseName = fileName.replace(".ts", "");
    const schemaKey = module.schemaKey;

    imports.push(
      `import { ${schemaKey} } from "../src/schemas/${baseName}.js";`,
    );
    schemaList.push(schemaKey);

    if (schema.$id !== "definitions.json") {
      const title = schema.title.replace(/\s+/g, "");
      exports.push(
        `export const validate${title} = ajv.compile(${schemaKey});`,
      );
    }
  }

  return `${banner}
import { Ajv } from "ajv";
import addFormats from "ajv-formats";

${imports.join("\n")}

const schemas = [
  ${schemaList.join(",\n  ")}
];

const ajv = new Ajv({
  allErrors: true,
  useDefaults: true,
  strict: false,
  allowMatchingProperties: true,
  allowUnionTypes: true,
  strictRequired: false,
  schemas: schemas,
});

addFormats(ajv);

${exports.join("\n")}
`;
}

function generateModelCode(schema, schemaModule, names) {
  const {
    methods = {},
    statics = {},
    getters = {},
    setters = {},
  } = schemaModule;

  const { schemaVar, typeName, className, fileName } = names;
  const properties = schema.properties || {};
  const required = schema.required || [];

  // Check if schema uses oneOf/anyOf which creates union types
  const hasUnionType = Boolean(schema.oneOf || schema.anyOf);

  // Generate property assignments
  const propertyAssignments = Object.keys(properties)
    .map((prop) => {
      const isRequired = required.includes(prop);
      if (!isRequired) {
        return `    if (data.${prop} !== undefined) this.${prop} = data.${prop};`;
      }
      return `    this.${prop} = data.${prop};`;
    })
    .join("\n");

  // Extract method source code from the original TypeScript file to preserve type annotations
  const sourceFile = `src/schemas/${fileName}.ts`;
  const methodsSource = extractMethodsFromSource(sourceFile, "methods");
  const staticsSource = extractMethodsFromSource(sourceFile, "statics");
  const gettersSource = extractMethodsFromSource(sourceFile, "getters");
  const settersSource = extractMethodsFromSource(sourceFile, "setters");

  // Generate static methods using source extraction
  const staticMethods = Object.keys(statics)
    .map((name) => {
      const source = staticsSource.get(name);
      if (source) {
        return `  static ${source}`;
      }
      // Fallback to toString() if source extraction fails
      const funcStr = statics[name].toString();
      const body = funcStr.slice(funcStr.indexOf("("));
      return `  static ${name}${body}`;
    })
    .join("\n\n");

  // Generate instance methods using source extraction
  const instanceMethods = Object.keys(methods)
    .map((name) => {
      const source = methodsSource.get(name);
      if (source) {
        return `  ${source}`;
      }
      // Fallback to toString() if source extraction fails
      const funcStr = methods[name].toString();
      const body = funcStr.slice(funcStr.indexOf("("));
      return `  ${name}${body}`;
    })
    .join("\n\n");

  // Generate getters using source extraction
  const getterMethods = Object.keys(getters)
    .map((name) => {
      const source = gettersSource.get(name);
      if (source) {
        return `  get ${source}`;
      }
      // Fallback to toString() if source extraction fails
      const funcStr = getters[name].toString();
      const body = funcStr.slice(funcStr.indexOf("("));
      return `  get ${name}${body}`;
    })
    .join("\n\n");

  // Generate setters using source extraction
  const setterMethods = Object.keys(setters)
    .map((name) => {
      const source = settersSource.get(name);
      if (source) {
        return `  set ${source}`;
      }
      // Fallback to toString() if source extraction fails
      const funcStr = setters[name].toString();
      const body = funcStr.slice(funcStr.indexOf("("));
      return `  set ${name}${body}`;
    })
    .join("\n\n");

  // For union types (oneOf/anyOf), we can't use interface extension or implements
  // Instead, we use an index signature and cast in the constructor
  const declarationMerging = hasUnionType
    ? `// Union type schema - using index signature since union types can't be extended
export class ${className} extends Entity {
  [key: string]: unknown;
  declare schema: typeof ${schemaVar};
  declare validator: typeof validate;`
    : `export interface ${className} extends ${typeName} {}
export class ${className} extends Entity {
  declare schema: typeof ${schemaVar};
  declare validator: typeof validate;`;

  // Generate the data type alias for backwards compatibility
  const dataTypeAlias = `${className}Data`;

  return `${banner}

import { Entity } from "../../src/models/entity.js";
import { validate${className} as validate } from "../validate.js";
import { ${schemaVar}, type ${typeName} } from "../../src/schemas/${fileName}.js";

/**
 * Data type for ${className} constructor - exported for backwards compatibility
 */
export type ${dataTypeAlias} = ${typeName};

/**
 * ${schema.description || className}
 */
${declarationMerging}

  constructor(data: ${typeName}) {
    super(data);
${propertyAssignments}
  }

${staticMethods}

${instanceMethods}

${getterMethods}

${setterMethods}
}

Object.defineProperty(${className}.prototype, "schema", {
  value: ${schemaVar}
});

Object.defineProperty(${className}.prototype, "validator", {
  get: function() { return validate; }
});
`;
}

function generateModelsIndex(modelNames) {
  const exports = modelNames
    .map(
      ({ className, fileName }) =>
        `export { ${className}, type ${className}Data } from "./${fileName}.js";`,
    )
    .join("\n");

  // Also export Entity from the source models folder
  const entityExport = `export { Entity } from "../../src/models/entity.js";`;

  return `${banner}\n\n${entityExport}\n\n${exports}\n`;
}

function generateUseCasesIndex(useCaseNames) {
  const exports = useCaseNames
    .map((name) => {
      const className =
        name.charAt(0).toUpperCase() + name.slice(1) + "Command";
      return `export { ${className} } from "./${name}.js";`;
    })
    .join("\n");

  return `${banner}\n\n${exports}\n`;
}

/**
 * @param {string} useCase - The name of the use case
 * @param {{method: "GET" | "PUT" | "POST" | "DELETE", path: string}} config
 * @param {string} description
 */
function generateUseCaseCode(
  useCase,
  { method, path: endpoint },
  description = "",
) {
  const pathParams =
    endpoint.match(/:[a-zA-Z0-9]+/g)?.map((param) => param.replace(":", "")) ||
    [];

  const httpMethod = method.toLowerCase();
  const classId = `${useCase.charAt(0).toUpperCase() + useCase.slice(1)}Command`;

  // Generate TypeScript interface for the command config
  const hasPathParams = pathParams.length > 0;
  const dataType = hasPathParams
    ? `{ ${pathParams.map((p) => `${p}: string`).join("; ")}; [key: string]: unknown }`
    : `Record<string, unknown>`;

  return `${banner}

export interface ${classId}Config {
  data?: ${dataType} | null;
  headers?: Record<string, string> | null;
  query?: Record<string, unknown> | null;
}

export interface ${classId}RequestConfig {
  method: "${httpMethod}";
  url: string;
  data: ${dataType} | null;
  params: Record<string, unknown> | null;
  headers: Record<string, string> | null;
  [key: string]: unknown;
}

/**
 * ${description}
 */
export class ${classId} {
  url: string;
  data: ${dataType} | null;
  query: Record<string, unknown> | null;
  headers: Record<string, string> | null;
  config: ${classId}RequestConfig;

  static params = ${JSON.stringify(pathParams)} as const;
  static url = "${endpoint}";
  static method = "${httpMethod}" as const;

  constructor(commandConfig: ${classId}Config, options: Record<string, unknown> = {}) {
    const pathParams = ${classId}.params;

    let { data, query, headers } = commandConfig ?? {};

    if (typeof data === "undefined") data = null;
    if (typeof query === "undefined") query = null;
    if (typeof headers === "undefined") headers = null;

    // Replace path parameters with values from data
    let url: string = ${classId}.url;

    if (pathParams && data) {
      for (const param of pathParams) {
        const urlParam = ":" + param;
        url = url.replace(urlParam, (data as Record<string, string>)[param]);
      }
    }

    // Make sure all parameters have been replaced
    const missingParams = url.match(/:[a-zA-Z0-9]+/g);
    if (missingParams) {
      const missing = missingParams.map((param) => param.replace(":", ""));
      throw new Error("Missing parameters: " + missing.join(", "));
    }

    this.url = url;
    this.data = data;
    this.query = query;
    this.headers = headers;

    this.config = {
      method: ${classId}.method,
      url: url,
      data: data,
      params: query,
      headers: headers,
      ...options,
    };
  }
}
`;
}
